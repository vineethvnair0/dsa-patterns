<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breadth-First Search (BFS) Pattern - DSA Patterns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            position: relative;
        }

        .back-button {
            display: inline-block;
            color: white;
            text-decoration: none;
            font-size: 1.1em;
            margin-bottom: 20px;
            padding: 8px 16px;
            border: 2px solid white;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: white;
            color: #667eea;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .category-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            color: #667eea;
            font-size: 1.8em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        .section h3 {
            color: #2c3e50;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }

        .section p {
            color: #555;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .problem-box {
            margin: 25px 0;
            padding: 20px;
            background: #f0f7ff;
            border-left: 4px solid #667eea;
            border-radius: 4px;
        }

        .problem-box strong {
            color: #667eea;
            font-size: 1.1em;
        }

        .example-box {
            background: #fff;
            padding: 15px;
            margin-top: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            border: 1px solid #e0e0e0;
        }

        .code-example {
            margin: 25px 0;
            padding: 20px;
            background: #2c3e50;
            color: #ecf0f1;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            overflow-x: auto;
            line-height: 1.6;
            white-space: pre;
        }

        .code-example .keyword {
            color: #c678dd;
        }

        .code-example .function {
            color: #61afef;
        }

        .code-example .string {
            color: #98c379;
        }

        .code-example .comment {
            color: #5c6370;
            font-style: italic;
        }

        .explanation-box {
            margin: 25px 0;
            padding: 20px;
            background: #f9f9f9;
            border-left: 4px solid #4caf50;
            border-radius: 4px;
        }

        .explanation-box strong {
            color: #4caf50;
            font-size: 1.1em;
        }

        .explanation-box ol, .explanation-box ul {
            margin: 15px 0 15px 25px;
        }

        .explanation-box li {
            color: #555;
            margin-bottom: 10px;
            line-height: 1.8;
        }

        .complexity {
            margin: 25px 0;
            padding: 15px 20px;
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            border-radius: 4px;
        }

        .complexity strong {
            color: #e65100;
        }

        .practice-problems {
            margin-top: 30px;
        }

        .problem-item {
            background: #fff;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .problem-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .problem-header {
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 15px;
            background: #f8f9fa;
            transition: background 0.3s ease;
        }

        .problem-header:hover {
            background: #e9ecef;
        }

        .problem-difficulty {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
            color: white;
        }

        .problem-difficulty.easy {
            background: #4caf50;
        }

        .problem-difficulty.medium {
            background: #ff9800;
        }

        .problem-difficulty.hard {
            background: #f44336;
        }

        .problem-title {
            flex: 1;
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.05em;
        }

        .expand-icon {
            color: #667eea;
            font-size: 1.2em;
            transition: transform 0.3s ease;
        }

        .problem-item.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .problem-details {
            display: none;
            padding: 20px;
            background: white;
            border-top: 1px solid #e0e0e0;
        }

        .problem-details p {
            margin-bottom: 15px;
            line-height: 1.6;
            color: #555;
        }

        .problem-details pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #667eea;
            overflow-x: auto;
            margin: 10px 0;
        }

        .problem-details a {
            display: inline-block;
            margin-top: 10px;
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .problem-details a:hover {
            color: #5568d3;
        }

        .difficulty-section {
            margin-bottom: 40px;
        }

        .difficulty-section h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 2em;
            }

            .content {
                padding: 20px;
            }

            .problem-header {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="../index.html" class="back-button">← Back to All Patterns</a>
            <h1>Pattern 11: Breadth-First Search (BFS)</h1>
            <span class="category-badge">Graphs</span>
        </header>

        <div class="content">
            <div class="section">
                <h2>Pattern Overview</h2>
                <p>Breadth-First Search (BFS) is a graph traversal algorithm that explores nodes level by level, starting from a source node and visiting all neighbors before moving to the next level. It uses a queue data structure to keep track of nodes to visit next.</p>
                <p>BFS is particularly useful for finding the shortest path in unweighted graphs, exploring all possible states in a problem space, and solving problems that require level-order traversal.</p>
            </div>

            <div style="background: #e0e7ff; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: #2d3748; margin-bottom: 10px;">Problem: Shortest Path in Binary Matrix</h3>
                <p style="color: #4a5568; line-height: 1.8; margin-bottom: 15px;">
                    Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.
                </p>

                <div style="background: white; padding: 15px; border-radius: 5px; margin: 10px 0;">
                    <strong>Example:</strong><br>
                    <strong style="color: #667eea;">Input:</strong> grid = [[0,1],[1,0]]<br>
                    <strong style="color: #10b981;">Output:</strong> 2<br>
                    <strong>Explanation:</strong> The path is from (0,0) to (1,1)
                </div>

                <h3 style="color: #2d3748; margin: 15px 0 10px 0;">How it works:</h3>
                <ul style="color: #4a5568; line-height: 1.8; margin-left: 20px;">
                    <li>Start from the source node and add it to a queue</li>
                    <li>Mark the source node as visited</li>
                    <li>While the queue is not empty, dequeue a node and visit all its unvisited neighbors</li>
                    <li>Add each unvisited neighbor to the queue and mark as visited</li>
                    <li>This ensures we explore nodes level by level</li>
                    <li>BFS guarantees the shortest path in unweighted graphs</li>
                </ul>
            </div>

            <div class="section">
                <h2>Example Problem</h2>
                <div class="problem-box">
                    <strong>Problem: Number of Islands</strong>
                    <p style="margin-top: 10px; color: #555;">
                        Given an m x n 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands.
                    </p>
                    <div style="margin-top: 15px;">
                        <strong style="color: #667eea;">Example 1:</strong>
                        <div class="example-box">
                            <strong>Input:</strong> grid = [<br>
                            &nbsp;&nbsp;["1","1","0","0","0"],<br>
                            &nbsp;&nbsp;["1","1","0","0","0"],<br>
                            &nbsp;&nbsp;["0","0","1","0","0"],<br>
                            &nbsp;&nbsp;["0","0","0","1","1"]<br>
                            ]<br>
                            <strong>Output:</strong> 3
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Solution Code</h2>
                <div class="code-example"><span class="comment">// Number of Islands using BFS</span>
<span class="keyword">public int</span> <span class="function">numIslands</span>(<span class="keyword">char</span>[][] grid) {
    <span class="keyword">if</span> (grid == null || grid.length == 0) <span class="keyword">return</span> 0;

    <span class="keyword">int</span> m = grid.length, n = grid[0].length;
    <span class="keyword">int</span> islands = 0;

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; m; i++) {
        <span class="keyword">for</span> (<span class="keyword">int</span> j = 0; j &lt; n; j++) {
            <span class="keyword">if</span> (grid[i][j] == '1') {
                islands++;
                bfs(grid, i, j);
            }
        }
    }
    <span class="keyword">return</span> islands;
}

<span class="keyword">private void</span> <span class="function">bfs</span>(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j) {
    <span class="keyword">int</span> m = grid.length, n = grid[0].length;
    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();
    queue.offer(<span class="keyword">new int</span>[]{i, j});
    grid[i][j] = '0'; <span class="comment">// Mark as visited</span>

    <span class="keyword">int</span>[][] dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};

    <span class="keyword">while</span> (!queue.isEmpty()) {
        <span class="keyword">int</span>[] curr = queue.poll();

        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) {
            <span class="keyword">int</span> x = curr[0] + dir[0];
            <span class="keyword">int</span> y = curr[1] + dir[1];

            <span class="keyword">if</span> (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n
                &amp;&amp; grid[x][y] == '1') {
                queue.offer(<span class="keyword">new int</span>[]{x, y});
                grid[x][y] = '0';
            }
        }
    }
}</div>
            </div>

            <div class="section">
                <h2>Solution Explanation</h2>
                <div class="explanation-box">
                    <strong>Step-by-Step Breakdown:</strong>
                    <p style="margin-top: 10px; color: #555; line-height: 1.6;">
                        The BFS approach systematically explores connected land cells:
                    </p>
                    <ol>
                        <li><strong>Initialize:</strong> Iterate through each cell in the grid.</li>
                        <li><strong>Find unvisited land:</strong> When we find a '1' (land), increment island count and start BFS from that cell.</li>
                        <li><strong>BFS traversal:</strong> Use a queue to visit all connected land cells:
                            <ul style="margin-left: 20px; margin-top: 5px;">
                                <li>Add the starting cell to the queue and mark it as visited</li>
                                <li>Process each cell from the queue and check all 4 neighbors</li>
                                <li>If a neighbor is land ('1'), add it to the queue and mark as visited</li>
                            </ul>
                        </li>
                        <li><strong>Complete island:</strong> When the queue is empty, we've explored the entire island.</li>
                        <li><strong>Continue:</strong> Move to the next unvisited cell and repeat.</li>
                    </ol>
                    <p style="margin-top: 15px; color: #555; line-height: 1.6;">
                        <strong>Key Insight:</strong> BFS explores all connected cells level by level, ensuring we visit every cell of an island before moving to the next island.
                    </p>
                </div>
            </div>

            <div class="section">
                <h2>Complexity Analysis</h2>
                <div class="complexity">
                    <strong>Time Complexity:</strong> O(m × n) | <strong>Space Complexity:</strong> O(min(m, n))
                </div>
                <div style="margin-top: 15px; color: #555; line-height: 1.6;">
                    <p><strong>Time Complexity: O(m × n)</strong></p>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li>We visit each cell at most once</li>
                        <li>For each cell, we check at most 4 neighbors</li>
                        <li>Total operations: O(m × n × 4) = O(m × n)</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Space Complexity: O(min(m, n))</strong></p>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li>Queue size depends on the grid dimensions</li>
                        <li>In the worst case, the queue contains all cells of one dimension</li>
                        <li>For a grid with more rows than columns, queue size is O(n); otherwise O(m)</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h2>Common Use Cases</h2>
                <ul style="margin-left: 25px; color: #555; line-height: 1.8;">
                    <li>Shortest path in unweighted graphs</li>
                    <li>Finding connected components</li>
                    <li>Level-order traversal of trees</li>
                    <li>Word ladder problems</li>
                    <li>Maze solving (shortest path)</li>
                    <li>Social network connections</li>
                </ul>
            </div>

            <div class="section practice-problems">
                <h2>Practice Problems</h2>
                <p style="color: #555; margin-bottom: 25px;">Master the Breadth-First Search pattern with these 15 curated LeetCode problems. Click on any problem to see the full description, examples, and constraints.</p>

                <div class="difficulty-section">
                    <h3>Easy Problems (5)</h3>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem1')">
                            <span class="problem-difficulty easy">Easy</span>
                            <span class="problem-title">100. Same Tree</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem1" class="problem-details">
                            <p><strong>Description:</strong> Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: p = [1,2,3], q = [1,2,3]
Output: true</pre>
                            <p><strong>Example 2:</strong></p>
                            <pre>Input: p = [1,2], q = [1,null,2]
Output: false</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>The number of nodes in both trees is in the range [0, 100]</li>
                                <li>-10^4 <= Node.val <= 10^4</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/same-tree/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem2')">
                            <span class="problem-difficulty easy">Easy</span>
                            <span class="problem-title">111. Minimum Depth of Binary Tree</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem2" class="problem-details">
                            <p><strong>Description:</strong> Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: root = [3,9,20,null,null,15,7]
Output: 2</pre>
                            <p><strong>Example 2:</strong></p>
                            <pre>Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>The number of nodes in the tree is in the range [0, 10^5]</li>
                                <li>-1000 <= Node.val <= 1000</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem3')">
                            <span class="problem-difficulty easy">Easy</span>
                            <span class="problem-title">993. Cousins in Binary Tree</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem3" class="problem-details">
                            <p><strong>Description:</strong> Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: root = [1,2,3,4], x = 4, y = 3
Output: false</pre>
                            <p><strong>Example 2:</strong></p>
                            <pre>Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
Output: true</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>The number of nodes in the tree is in the range [2, 100]</li>
                                <li>1 <= Node.val <= 100</li>
                                <li>Each node has a unique value</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/cousins-in-binary-tree/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem4')">
                            <span class="problem-difficulty easy">Easy</span>
                            <span class="problem-title">1971. Find if Path Exists in Graph</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem4" class="problem-details">
                            <p><strong>Description:</strong> There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges. Given vertices source and destination, return true if there is a valid path from source to destination, or false otherwise.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
Output: true
Explanation: There are two paths from vertex 0 to vertex 2:
- 0 → 1 → 2
- 0 → 2</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>1 <= n <= 2 * 10^5</li>
                                <li>0 <= edges.length <= 2 * 10^5</li>
                                <li>0 <= source, destination < n</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/find-if-path-exists-in-graph/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem5')">
                            <span class="problem-difficulty easy">Easy</span>
                            <span class="problem-title">690. Employee Importance</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem5" class="problem-details">
                            <p><strong>Description:</strong> You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs. Given an employee ID, return the total importance value of this employee and all their direct and indirect subordinates.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1
Output: 11
Explanation: Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3. They both have an importance value of 3. Thus the total importance value of employee 1 is 5 + 3 + 3 = 11.</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>1 <= employees.length <= 2000</li>
                                <li>1 <= employee[i].id <= 2000</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/employee-importance/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>
                </div>

                <div class="difficulty-section">
                    <h3>Medium Problems (5)</h3>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem6')">
                            <span class="problem-difficulty medium">Medium</span>
                            <span class="problem-title">200. Number of Islands</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem6" class="problem-details">
                            <p><strong>Description:</strong> Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>m == grid.length</li>
                                <li>n == grid[i].length</li>
                                <li>1 <= m, n <= 300</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem7')">
                            <span class="problem-difficulty medium">Medium</span>
                            <span class="problem-title">127. Word Ladder</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem7" class="problem-details">
                            <p><strong>Description:</strong> A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that every adjacent pair of words differs by a single letter. Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> "cog", which is 5 words long.</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>1 <= beginWord.length <= 10</li>
                                <li>endWord.length == beginWord.length</li>
                                <li>1 <= wordList.length <= 5000</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/word-ladder/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem8')">
                            <span class="problem-difficulty medium">Medium</span>
                            <span class="problem-title">542. 01 Matrix</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem8" class="problem-details">
                            <p><strong>Description:</strong> Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]</pre>
                            <p><strong>Example 2:</strong></p>
                            <pre>Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>m == mat.length</li>
                                <li>n == mat[i].length</li>
                                <li>1 <= m, n <= 10^4</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/01-matrix/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem9')">
                            <span class="problem-difficulty medium">Medium</span>
                            <span class="problem-title">994. Rotting Oranges</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem9" class="problem-details">
                            <p><strong>Description:</strong> You are given an m x n grid where each cell can have one of three values: 0 (empty), 1 (fresh orange), or 2 (rotten orange). Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>m == grid.length</li>
                                <li>n == grid[i].length</li>
                                <li>1 <= m, n <= 10</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/rotting-oranges/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem10')">
                            <span class="problem-difficulty medium">Medium</span>
                            <span class="problem-title">1091. Shortest Path in Binary Matrix</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem10" class="problem-details">
                            <p><strong>Description:</strong> Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell to the bottom-right cell such that all the visited cells of the path are 0.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: grid = [[0,1],[1,0]]
Output: 2</pre>
                            <p><strong>Example 2:</strong></p>
                            <pre>Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
Output: 4</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>n == grid.length</li>
                                <li>n == grid[i].length</li>
                                <li>1 <= n <= 100</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>
                </div>

                <div class="difficulty-section">
                    <h3>Hard Problems (5)</h3>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem11')">
                            <span class="problem-difficulty hard">Hard</span>
                            <span class="problem-title">126. Word Ladder II</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem11" class="problem-details">
                            <p><strong>Description:</strong> A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words such that every adjacent pair of words differs by a single letter. Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>1 <= beginWord.length <= 5</li>
                                <li>endWord.length == beginWord.length</li>
                                <li>1 <= wordList.length <= 500</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem12')">
                            <span class="problem-difficulty hard">Hard</span>
                            <span class="problem-title">1036. Escape a Large Maze</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem12" class="problem-details">
                            <p><strong>Description:</strong> There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y). We start at the source = [sx, sy] square and want to reach the target = [tx, ty] square. There is also an array of blocked squares, where each blocked[i] = [xi, yi] represents a blocked square. Return true if and only if it is possible to reach the target square from the source square through a sequence of valid moves.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
Output: false</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>0 <= blocked.length <= 200</li>
                                <li>blocked[i].length == 2</li>
                                <li>0 <= xi, yi < 10^6</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/escape-a-large-maze/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem13')">
                            <span class="problem-difficulty hard">Hard</span>
                            <span class="problem-title">317. Shortest Distance from All Buildings</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem13" class="problem-details">
                            <p><strong>Description:</strong> You are given an m x n grid where each cell is one of: 0 (empty land), 1 (building), or 2 (obstacle). You want to build a house on an empty land that reaches all buildings in the shortest total travel distance. Return the shortest travel distance for such a house. If it is not possible to build such a house, return -1.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: grid = [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]
Output: 7
Explanation: The point (1,2) is an ideal empty land to build a house.</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>m == grid.length</li>
                                <li>n == grid[i].length</li>
                                <li>1 <= m, n <= 50</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem14')">
                            <span class="problem-difficulty hard">Hard</span>
                            <span class="problem-title">1293. Shortest Path in a Grid with Obstacles Elimination</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem14" class="problem-details">
                            <p><strong>Description:</strong> You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step. Return the minimum number of steps to walk from the upper left corner to the lower right corner given that you can eliminate at most k obstacles.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
Output: 6</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>m == grid.length</li>
                                <li>n == grid[i].length</li>
                                <li>1 <= m, n <= 40</li>
                                <li>1 <= k <= m * n</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem('problem15')">
                            <span class="problem-difficulty hard">Hard</span>
                            <span class="problem-title">815. Bus Routes</span>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div id="problem15" class="problem-details">
                            <p><strong>Description:</strong> You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever. You will start at the bus stop source and want to go to the bus stop target. Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.</p>
                            <p><strong>Example 1:</strong></p>
                            <pre>Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
Output: 2
Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.</pre>
                            <p><strong>Constraints:</strong></p>
                            <ul>
                                <li>1 <= routes.length <= 500</li>
                                <li>1 <= routes[i].length <= 10^5</li>
                                <li>0 <= routes[i][j] < 10^6</li>
                            </ul>
                            <p><a href="https://leetcode.com/problems/bus-routes/" target="_blank">Solve on LeetCode →</a></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>Master this pattern through consistent practice. Good luck!</p>
            <p style="margin-top: 10px; opacity: 0.8;">© 2025 DSA Coding Patterns Guide</p>
        </footer>
    </div>

    <script>
        function toggleProblem(id) {
            var element = document.getElementById(id);
            var problemItem = element.parentElement;

            if (element.style.display === "none" || element.style.display === "") {
                element.style.display = "block";
                problemItem.classList.add('expanded');
            } else {
                element.style.display = "none";
                problemItem.classList.remove('expanded');
            }
        }
    </script>
</body>
</html>
