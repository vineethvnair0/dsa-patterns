<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Breadth-First Search Pattern - DSA Patterns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
        }

        .back-button {
            display: inline-block;
            color: white;
            text-decoration: none;
            font-size: 1.1em;
            margin-bottom: 20px;
            padding: 8px 16px;
            border: 2px solid white;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: white;
            color: #667eea;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .category-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            color: #667eea;
            font-size: 1.8em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        .section p {
            color: #555;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .section ul {
            margin-left: 25px;
            color: #555;
            line-height: 1.8;
        }

        .section li {
            margin-bottom: 8px;
        }

        .practice-problems {
            margin-top: 30px;
        }

        .difficulty-section {
            margin-bottom: 30px;
        }

        .difficulty-header {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .difficulty-header.easy {
            background: #4caf50;
        }

        .difficulty-header.medium {
            background: #ff9800;
        }

        .difficulty-header.hard {
            background: #f44336;
        }

        .problem-list {
            list-style: none;
        }

        .problem-item {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }

        .problem-item:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .problem-item a {
            color: #2c3e50;
            text-decoration: none;
            font-weight: 500;
        }

        .problem-item a:hover {
            color: #667eea;
        }

        .problem-number {
            color: #667eea;
            font-weight: bold;
            margin-right: 10px;
        }

        .problem-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .problem-title {
            flex: 1;
        }

        .toggle-icon {
            color: #667eea;
            font-size: 1.2em;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .problem-details {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .problem-details.show {
            display: block;
        }

        .problem-description {
            color: #555;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .problem-example {
            background: white;
            padding: 12px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .problem-constraints {
            color: #666;
            font-size: 0.9em;
            margin: 10px 0;
        }

        .leetcode-link {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            text-decoration: none;
            margin-top: 10px;
            transition: background 0.3s ease;
        }

        .leetcode-link:hover {
            background: #764ba2;
            color: white;
        }

        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 2em;
            }

            .content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="../index.html" class="back-button">← Back to All Patterns</a>
            <h1>Pattern 18: Tree Breadth-First Search</h1>
            <span class="category-badge">Trees</span>
        </header>

        <div class="content">
            <div class="section">
                <h2>Pattern Overview</h2>
                <p>This pattern is essential for solving specific types of algorithmic problems efficiently. It provides a systematic approach to tackle common challenges in coding interviews.</p>
                <p>Understanding when and how to apply this pattern will significantly improve your problem-solving skills and interview performance.</p>
            </div>

            <div style="background: #e0e7ff; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: #2d3748; margin-bottom: 10px;">Problem: Binary Tree Level Order Traversal</h3>
                <p style="color: #4a5568; line-height: 1.8; margin-bottom: 15px;">
                    Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).
                </p>

                <div style="background: white; padding: 15px; border-radius: 5px; margin: 10px 0;">
                    <strong>Example:</strong><br>
                    <strong style="color: #667eea;">Input:</strong> root = [3,9,20,null,null,15,7]<br>
                    <strong style="color: #10b981;">Output:</strong> [[3], [9,20], [15,7]]
                </div>

                <h3 style="color: #2d3748; margin: 15px 0 10px 0;">How BFS works:</h3>
                <ul style="color: #4a5568; line-height: 1.8; margin-left: 20px;">
                    <li><strong>Breadth-First Search</strong> explores nodes level by level</li>
                    <li>Use a <strong>queue</strong> to track nodes at each level</li>
                    <li>Add root to queue, then process level by level:</li>
                    <li>1. Get current level size</li>
                    <li>2. Process all nodes at current level</li>
                    <li>3. Add their children to queue for next level</li>
                    <li>Time complexity: O(n), Space complexity: O(w) where w = max width</li>
                    <li>Perfect for level-order traversal, finding shortest path, or level-specific operations</li>
                </ul>
            </div>

            <div class="section">
                <h2>Key Concepts</h2>
                <p>This pattern demonstrates fundamental algorithmic techniques that are frequently tested in technical coding interviews.</p>
                <p>Master this pattern by practicing the curated problems below, starting with easy problems to build foundational understanding, then progressing to medium and hard problems to develop expertise.</p>
            </div>

            <div class="section practice-problems">
                <h2>Practice Problems</h2>
                <p style="color: #555; margin-bottom: 25px;">Master the Tree Breadth-First Search pattern with these 15 curated LeetCode problems organized by difficulty level. Each problem has been carefully selected to help you understand and apply this pattern effectively.</p>

                <div class="difficulty-section">
                    <div class="difficulty-header easy">Easy Problems</div>
                    <ul class="problem-list">
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">102.</span>
                                    <span>Binary Tree Level Order Traversal</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [3,9,20,null,null,15,7]<br>
                                    Output: [[3],[9,20],[15,7]]
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [0, 2000]<br>
                                    • -1000 ≤ Node.val ≤ 1000
                                </div>
                                <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">637.</span>
                                    <span>Average of Levels in Binary Tree</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [3,9,20,null,null,15,7]<br>
                                    Output: [3.00000,14.50000,11.00000]<br>
                                    Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [1, 10^4]<br>
                                    • -2^31 ≤ Node.val ≤ 2^31 - 1
                                </div>
                                <a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">111.</span>
                                    <span>Minimum Depth of Binary Tree</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [3,9,20,null,null,15,7]<br>
                                    Output: 2<br>
                                    Explanation: The shortest path is 3 → 9
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [0, 10^5]<br>
                                    • -1000 ≤ Node.val ≤ 1000
                                </div>
                                <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">104.</span>
                                    <span>Maximum Depth of Binary Tree</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [3,9,20,null,null,15,7]<br>
                                    Output: 3<br>
                                    Explanation: The longest path is 3 → 20 → 15 (or 7)
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [0, 10^4]<br>
                                    • -100 ≤ Node.val ≤ 100
                                </div>
                                <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">993.</span>
                                    <span>Cousins in Binary Tree</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree with unique values and the values of two different nodes x and y, return true if the nodes corresponding to the values x and y are cousins, or false otherwise. Two nodes are cousins if they have the same depth but have different parents.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [1,2,3,4], x = 4, y = 3<br>
                                    Output: false<br>
                                    Explanation: 4 and 3 have different depths
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [2, 100]<br>
                                    • 1 ≤ Node.val ≤ 100<br>
                                    • Each node has a unique value
                                </div>
                                <a href="https://leetcode.com/problems/cousins-in-binary-tree/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                    </ul>
                </div>

                <div class="difficulty-section">
                    <div class="difficulty-header medium">Medium Problems</div>
                    <ul class="problem-list">
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">199.</span>
                                    <span>Binary Tree Right Side View</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [1,2,3,null,5,null,4]<br>
                                    Output: [1,3,4]<br>
                                    Explanation: From the right side, you can see nodes 1, 3, and 4
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [0, 100]<br>
                                    • -100 ≤ Node.val ≤ 100
                                </div>
                                <a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">103.</span>
                                    <span>Binary Tree Zigzag Level Order Traversal</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree, return the zigzag level order traversal of its nodes' values (i.e., from left to right, then right to left for the next level and alternate between).
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [3,9,20,null,null,15,7]<br>
                                    Output: [[3],[20,9],[15,7]]<br>
                                    Explanation: First level left to right, second level right to left, third level left to right
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [0, 2000]<br>
                                    • -100 ≤ Node.val ≤ 100
                                </div>
                                <a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">515.</span>
                                    <span>Find Largest Value in Each Tree Row</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [1,3,2,5,3,null,9]<br>
                                    Output: [1,3,9]<br>
                                    Explanation: Level 0: max is 1, Level 1: max is 3, Level 2: max is 9
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [0, 10^4]<br>
                                    • -2^31 ≤ Node.val ≤ 2^31 - 1
                                </div>
                                <a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">116.</span>
                                    <span>Populating Next Right Pointers in Each Node</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [1,2,3,4,5,6,7]<br>
                                    Output: [1,#,2,3,#,4,5,6,7,#]<br>
                                    Explanation: Connect nodes at each level from left to right
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [0, 2^12 - 1]<br>
                                    • -1000 ≤ Node.val ≤ 1000
                                </div>
                                <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">1161.</span>
                                    <span>Maximum Level Sum of a Binary Tree</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on. Return the smallest level x such that the sum of all the values of nodes at level x is maximal.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [1,7,0,7,-8,null,null]<br>
                                    Output: 2<br>
                                    Explanation: Level 1 sum = 1, Level 2 sum = 7 + 0 = 7, Level 3 sum = 7 + (-8) = -1
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [1, 10^4]<br>
                                    • -10^5 ≤ Node.val ≤ 10^5
                                </div>
                                <a href="https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                    </ul>
                </div>

                <div class="difficulty-section">
                    <div class="difficulty-header hard">Hard Problems</div>
                    <ul class="problem-list">
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">297.</span>
                                    <span>Serialize and Deserialize Binary Tree</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [1,2,3,null,null,4,5]<br>
                                    Output: [1,2,3,null,null,4,5]<br>
                                    Explanation: Serialize the tree to a string, then deserialize it back to the original tree structure
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [0, 10^4]<br>
                                    • -1000 ≤ Node.val ≤ 1000
                                </div>
                                <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">314.</span>
                                    <span>Binary Tree Vertical Order Traversal</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree, return the vertical order traversal of its nodes' values (i.e., from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [3,9,20,null,null,15,7]<br>
                                    Output: [[9],[3,15],[20],[7]]<br>
                                    Explanation: Column -1: [9], Column 0: [3,15], Column 1: [20], Column 2: [7]
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [0, 100]<br>
                                    • -100 ≤ Node.val ≤ 100
                                </div>
                                <a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">987.</span>
                                    <span>Vertical Order Traversal of a Binary Tree</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    Given the root of a binary tree, calculate the vertical order traversal of the binary tree. For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root is at position (0, 0).
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [3,9,20,null,null,15,7]<br>
                                    Output: [[9],[3,15],[20],[7]]<br>
                                    Explanation: Sort nodes by column, then by row, then by value
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is in the range [1, 1000]<br>
                                    • 0 ≤ Node.val ≤ 1000
                                </div>
                                <a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">2458.</span>
                                    <span>Height of Binary Tree After Subtree Removal Queries</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m. For the ith query, you are allowed to remove the subtree rooted at the node with the value queries[i]. Return an array answer of size m where answer[i] is the height of the tree after performing the ith query.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]<br>
                                    Output: [2]<br>
                                    Explanation: After removing the subtree rooted at node 4, the height becomes 2
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • The number of nodes in the tree is n<br>
                                    • 2 ≤ n ≤ 10^5<br>
                                    • 1 ≤ Node.val ≤ n<br>
                                    • 1 ≤ queries.length ≤ min(n, 10^4)
                                </div>
                                <a href="https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                        <li class="problem-item">
                            <div class="problem-header" onclick="toggleProblem(this)">
                                <div class="problem-title">
                                    <span class="problem-number">2277.</span>
                                    <span>Closest Node to Path in Tree</span>
                                </div>
                                <span class="toggle-icon">▼</span>
                            </div>
                            <div class="problem-details">
                                <div class="problem-description">
                                    You are given a positive integer n representing the number of nodes in a tree, numbered from 0 to n - 1 (inclusive). You are also given a 2D integer array edges of length n - 1, where edges[i] = [node1i, node2i] denotes that there is a bidirectional edge connecting node1i and node2i in the tree. You are given a 0-indexed integer array query of length m where query[i] = [starti, endi, nodei] means that for the ith query, you are tasked with finding the node on the path from starti to endi that is closest to nodei.
                                </div>
                                <div class="problem-example">
                                    <strong>Example:</strong><br>
                                    Input: n = 7, edges = [[0,1],[0,2],[0,3],[1,4],[2,5],[2,6]], query = [[5,3,4],[5,3,6]]<br>
                                    Output: [0,2]<br>
                                    Explanation: For query 0, the path from 5 to 3 is 5->2->0->3, and node 0 is closest to 4
                                </div>
                                <div class="problem-constraints">
                                    <strong>Constraints:</strong><br>
                                    • 1 ≤ n ≤ 1000<br>
                                    • edges.length == n - 1<br>
                                    • 0 ≤ node1i, node2i ≤ n - 1<br>
                                    • 1 ≤ query.length ≤ 1000
                                </div>
                                <a href="https://leetcode.com/problems/closest-node-to-path-in-tree/" target="_blank" class="leetcode-link">Solve on LeetCode →</a>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <footer>
            <p>Master this pattern through consistent practice. Good luck with your interviews!</p>
            <p style="margin-top: 10px; opacity: 0.8;">© 2025 DSA Coding Patterns Guide</p>
        </footer>
    </div>

    <script>
        function toggleProblem(header) {
            const details = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');

            if (details.classList.contains('show')) {
                details.classList.remove('show');
                icon.classList.remove('expanded');
            } else {
                details.classList.add('show');
                icon.classList.add('expanded');
            }
        }
    </script>
</body>
</html>